<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="尋覓">
<meta property="og:type" content="website">
<meta property="og:title" content="尋覓">
<meta property="og:url" content="https://lsqpyer.github.io/index.html">
<meta property="og:site_name" content="尋覓">
<meta property="og:description" content="尋覓">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="尋覓">
<meta name="twitter:description" content="尋覓">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://lsqpyer.github.io/"/>





  <title> 尋覓 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">尋覓</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://lsqpyer.github.io/2017/03/17/惯用Python：推导/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="尋覓">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.bmp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="尋覓">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/17/惯用Python：推导/" itemprop="url">
                  惯用Python：推导
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-17T10:54:11+08:00">
                2017-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文：<a href="https://blogs.msdn.microsoft.com/pythonengineering/2016/03/14/idiomatic-python-comprehensions/" target="_blank" rel="external">Idiomatic Python: comprehensions</a></p>
<hr>
<p>很幸运，我们组有几个人已经用Python编程了相当长的一段时间（我自己现在已经使用这门语言超过15年了）。随着时间的推移，我们纷纷使用各种各样Python编程中的惯用手法，这些惯用手法可能不是很明显，或者处于各种原因并未广为人知。为了帮助大家分享一些这方面的知识，我们计划进行题为“地道的Python”的不定期的博客文章，在这里，我们选择一个主题，并提供关于它的一些小技巧。有些文章可能很长，有些则可能很短。无论哪种方式，我们都希望，你能从中得到一些有用的东西（即使是对于经验丰富的开发人员而言，因为我们可能会在这里那里讲到一点Python历史）。</p>
<p>对于该系列的首篇文字，我想我们可以谈谈推导。在几乎所有的编程语言中，填充一个容器的一个惯用手法就是使用<code>for</code>循环：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">container = []</div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> another_container:</div><div class="line">  container.append(x**<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>这是用一些对象填充诸如列表的容器的一种非常简单直接的方式。但是，这种惯用手法相当常见，以至于一遍又一遍的重复变成有点讨厌。这就是为什么在Python 2.0中，<a href="https://docs.python.org/3/glossary.html#term-list-comprehension" target="_blank" rel="external">列表推导</a>被<a href="https://docs.python.org/3/whatsnew/2.0.html#list-comprehensions" target="_blank" rel="external">添加到了Python中</a>:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">container = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> another_container]</div></pre></td></tr></table></figure>
<p>(小历史：Python中的列表推导是受<a href="https://wiki.haskell.org/List_comprehension" target="_blank" rel="external">Haskell中的列表推导</a>所启发的)。列表推导已被广泛用于Python社区，因为它们提供了一种以紧凑的方式来从另一个容器中创建一个列表的简单的方式(技术上来讲，是从另一个<a href="https://docs.python.org/3/glossary.html#term-iterable" target="_blank" rel="external">可迭代对象</a>，但是每种类型的容器都应该是一个可迭代对象)。得益于Python在背后暗戳戳做的一些事，列表推导也快于一个简单的<code>for</code>循环。</p>
<p>但你可能不知道的是，Python中还有生成器、字典和集合的推导版本。在Python 2.4中，<a href="https://docs.python.org/3/glossary.html#term-generator-expression" target="_blank" rel="external">生成器表达式</a>被<a href="https://docs.python.org/3/whatsnew/2.4.html#pep-289-generator-expressions" target="_blank" rel="external">添加到了Python中</a>。当你想通过不在内存中一次性创建一个完整的列表来节省内存，而只是想要使用需要的内存来一次创建序列中的一个项时（谁不想节省内存呢？），生成器和列表推导、生成器表达式的交叉使用是很棒的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">container = (x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> another_container)</div></pre></td></tr></table></figure>
<p>就像列表推导，生成器表达式或多或少是下面的语法糖：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> another_container:</div><div class="line">        <span class="keyword">yield</span> x**<span class="number">2</span></div><div class="line">container = _()</div><div class="line"><span class="keyword">del</span> _</div></pre></td></tr></table></figure>
<p>要真正了解这一点，你可以分别尝试下面的两个例子，但要注意，后者将需要一段时间才能完成：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Use xrange() instead of range() if you're using Python 2.7.</span></div><div class="line"><span class="comment"># Generator expression</span></div><div class="line">(<span class="string">'genexp'</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100000000</span>))</div><div class="line"><span class="comment"># List comprehension</span></div><div class="line">[<span class="string">'listcomp'</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100000000</span>)]</div></pre></td></tr></table></figure>
<p>每当你使用列表推导的时候，你应该停下来想想结果列表将如何被使用。如果该列表只是被当做一个<a href="https://docs.python.org/3/glossary.html#term-iterable" target="_blank" rel="external">可迭代对象</a> — 列表中的所有对象将被依次访问，正如在<code>for</code>循环中一样 — 那么你应该使用一个生成器表达式即可。</p>
<p>这也过渡到了这个惯用手法：在有可能的时候，指定你的API接受或返回一个可迭代对象，而不是一个指定的类型，例如一个列表。当你只关心一个对象序列时，指定你的API接受/返回可迭代对象，而不是一个具体的类型，例如一个列表。这一点与列表推导如何在Python 3中工作的很好的联系在一起，因为基本上生成器表达式加上对<code>list()</code>的调用，意味着返回一个可迭代对象，例如生成器表达式，并不会阻碍你的代码的用户轻松的获得一个列表，如果列表就是他们想要的话：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">container = list(x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> another_container)</div></pre></td></tr></table></figure>
<p>列表推导和生成器表达式变得如此受欢迎，以至于Python继续发展推导的概念，并<a href="https://docs.python.org/3/whatsnew/3.0.html#new-syntax" target="_blank" rel="external">在Python 3.0中引入了字典和集合推导</a> (它们被<a href="https://docs.python.org/3/whatsnew/2.7.html#python-3-1-features" target="_blank" rel="external">反向移植到Python 2.7</a>)。顾名思义，字典和集合推导提供了从<code>for</code>循环创建字典和集合的语法糖。集合推导看起来像是一个生成器表达式，但它使用的是花括号：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">container = &#123;x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> another_container&#125;</div></pre></td></tr></table></figure>
<p>字典推导看起来像集合推导，但字典中的每一项使用冒号来分开键值，就像在字典中一样：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">container = &#123;x: x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> another_container&#125;</div></pre></td></tr></table></figure>
<p>现在，你可能已经注意到了在所有Python内置的容器类型中，只有元组没有推导形式。这是故意的，因为推导并不意味着只是<code>for</code>循环的语法糖。由于你不能在一个<code>for</code>循环中创建一个元组，因此元组的推导形式是没有意义的。同时，很容易根据一个生成器表达式来创建一个元组，因此这并没有丢失掉任何功能，并且与使用<code>for</code>循环来创建一个列表，然后最后将其转换成一个元组相比，并没有任何性能损失：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">container = tuple(x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> another_container)</div></pre></td></tr></table></figure>
<p>总结一下：</p>
<ul>
<li>列表推导是受Haskell所启发的： <code>[x**2 for x in another_container]</code></li>
<li>生成器表达式就像列表推导一样，但它用于生成器：<code>(x**2 for x in another_container)</code></li>
<li>你应该总是尝试使用生成器表达式，而不是列表推导，并且只在你确实需要一个列表的时候使用列表推导</li>
<li>当你只关心对象序列时，指定你的API接受/返回可迭代对象，而不是具体的类型，例如，列表。</li>
<li>Python 2.7/3.0添加了集合推导：<code>{x**2 for x in another_container}</code></li>
<li>Python 2.7/3.0还添加了字典推导：<code>{x: x**2 for x in another_container}</code></li>
</ul>
<p>希望你觉得这篇文章有用！如果是的话，请告诉我们，以便我们能够衡量是否应该在未来写更多像这样的文章。（Ele注：请拉到文章开头，找到原文地址，去反馈吧！）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://lsqpyer.github.io/2017/03/17/惯用Python：布尔表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="尋覓">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.bmp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="尋覓">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/17/惯用Python：布尔表达式/" itemprop="url">
                  惯用Python：布尔表达式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-17T10:53:40+08:00">
                2017-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文：<a href="https://blogs.msdn.microsoft.com/pythonengineering/2016/04/18/idiomatic-python-boolean-expressions/" target="_blank" rel="external">Idiomatic Python: boolean expressions</a></p>
<hr>
<p>你可能会认为布尔表达式 —— 最常用于条件判读，是一点测试<code>if</code>或者<code>while</code>语句是否应该执行的代码 —— 是一个相当直接的概念，而且它们确实完全没有什么微妙之处。虽然一般概念是很简单的，但是在写布尔表达式时，有一些要遵循的惯用做法。</p>
<p>首先，要确保每个人都明白，是什么让某个东西被视为true或者false （有时也被称为是“真实”与否）。Python 3中，官方对<a href="https://docs.python.org/3/reference/expressions.html#booleans" target="_blank" rel="external">什么是true或者false的定义</a>是：</p>
<blockquote>
<p><code>False</code>, <code>None</code>, 所有类型的数字0, 以及空字符串和空容器 (包括字符串(string), 元组(tuple), 列表(list), 字典(dictionary), 集合(set)和frozenset)。所有其他值则被解析为true。通过提供一个<code>__bool__()</code>方法，用户定义的对象可以自定义它们的真值。</p>
</blockquote>
<p>Python的一点历史：在讨论<a href="https://docs.python.org/3/whatsnew/2.3.html#pep-285-a-boolean-type" target="_blank" rel="external">在Python 2.3中添加布尔类型</a>期间，对于什么是false的定义从“所有表示空的东西”变为“所有表示空的东西<strong>和</strong><code>False</code>”，有些人并不喜欢，他们觉得这样有失简单性。而另一些人则认为，<code>False</code>会让代码更加清晰。结果，支持<code>False</code>概念的人更多，因此，后者赢得了这场争论。你也许也注意到了，在Python中，布尔不不是<em>那么</em>老，这就是为什么布尔可以（大部分）被当成整型，因为它能与那些简单的使用<code>1</code>和<code>0</code>来分别表示<code>True</code>和<code>False</code>的代码向后兼容。</p>
<p>建议的第一条就是不要过分的使用<code>is</code>比较。<code>is</code>用于<a href="https://docs.python.org/3/reference/expressions.html#is-not" target="_blank" rel="external">标识比较(identity comparison)</a>，只有当表达式中的两个对象都表示同个对象的时候，它的计算结果才是<code>True</code>。不幸的是，人们总是会把标识比较和值比较混为一谈。例如，有些人意外地发现，出于对性能的考量，Python的某些实现中缓存了特定的值，导致像这样的表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">40</span> + <span class="number">2</span> <span class="keyword">is</span> <span class="number">42</span>  <span class="comment"># True in CPython, not necessarily in other VMs.</span></div></pre></td></tr></table></figure>
<p>为真。但是，对数字的缓存并不是Python语言定义的一部分，它只是实现细节中一个古怪的副作用。这是一个问题，如果你想要改变Python的实现，或者碰巧认为对任何数字使用<code>is</code>都有效，这显然不对，看看当你试图这样做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>**<span class="number">32</span> <span class="keyword">is</span> <span class="number">2</span>**<span class="number">32</span> <span class="comment"># False.</span></div></pre></td></tr></table></figure>
<p>结果会是<code>False</code>。换句话说，只有在你真的<strong>真的</strong>想要测试标识而不是值时，才使用<code>is</code>。</p>
<p>另一个我们看到<code>is</code>以一种非惯用方式使用的地方是直接测试<code>True</code>或者<code>False</code>，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">something() <span class="keyword">is</span> <span class="keyword">False</span>  <span class="comment"># Too restrictive.</span></div></pre></td></tr></table></figure>
<p>这在技术上并不像前面的例子那样是错误的，因为<code>False</code>是一个单子 —— 就像<code>None</code>和<code>True</code>一样 —— 这意味着，实际上<code>False</code>只有一个实例可以用来比较。但是这样做的问题在于，它带来了不必要的限制。幸好Python是<a href="https://en.wikipedia.org/wiki/Duck_typing" target="_blank" rel="external">鸭子类型(duck typing)</a>的庞大的支持者，不赞成将任何API的类型指定为<code>True</code>或者<code>False</code>，因为它将一个API锁定为指定的类型。假若出于某些原因，该API变成返回了另一种类型的值，但具有相同的布尔解释，那么，这个代码会突然崩溃。取代直接检查<code>False</code>的是，该代码应该简单检查假值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">not</span> something()  <span class="comment"># Just right.</span></div></pre></td></tr></table></figure>
<p>然后，这也可以扩展到其他类型。如果你关心某样东西是否是空的，那么不要<code>spam == []</code>，而是<code>not spam</code>，以防万一那个返回<code>spam</code>值的API突然开始返回元祖，而不是列表。</p>
<p>而你在日复一日的代码中唯一可能合理使用<code>is</code>的时候是，和<code>None</code>一起使用。有时，你可能会碰到一个API，其中，<code>None</code>具有特殊含义，在这种情况下，你应该使用<code>is None</code>来检查那个特殊值。例如，Python中的模块具有一个<a href="https://docs.python.org/3/reference/import.html#__package__" target="_blank" rel="external"><code>__package__</code>属性</a>，它存储了一个表示该模块属于哪个包的字符串。诀窍是，顶层模块，例如，不被包含在一个包中的那些模块，它们的<code>__package__</code>值为空字符串，这是假的，但却是一个有效值，但需要有一个值表示不知道<code>__package__</code>应该被设为什么值。在这种情况下，<code>None</code>被用来表示“我不知道”。这允许<a href="https://github.com/python/cpython/blob/d0ffca8d6aa055300f7361e4bea2d4def0fca571/Lib/importlib/_bootstrap.py#L1031" target="_blank" rel="external">计算一个模块属于哪个包的代码</a>使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">package <span class="keyword">is</span> <span class="keyword">None</span>  <span class="comment"># OK when you need an "I don't know" value.</span></div></pre></td></tr></table></figure>
<p>来检查是否包名未知 (<code>not package</code>会错误的认为<code>&#39;&#39;</code>也表示这个意思)。但请务必确保不滥用<code>None</code>的这种用法，因为false值趋向于满足表示“我不知道”的需要。</p>
<p>另一点建议是，在我们自己的类中定义<code>__bool__()</code>之前三思而后行。虽然你应该明确的定义表示容器的类的方法（以助于“若为假，则为空”的概念），但是在任何情况下，你都应该停下来想想定义该方法是否真的有意义。虽然使用<code>__bool__()</code>来表示一个对象的某种状态可能是很诱人的，但是后果会出奇的影响深远，因为它意味着，突然让人不得不开始明确检查一些特殊值，例如<code>None</code>，这表示一个API是否返回一个实际值，而不是简单的依赖着所有的对象默认都为值这种条件。作为定义<code>__bool__()</code>为嘛可能是令人惊讶的一个例子，见<a href="https://bugs.python.org/issue13936" target="_blank" rel="external">Python issue</a>，这里有一个多年的讨论，该讨论关于怎样定义<code>datetime.time()</code>在午夜的时候为false，其他时候都为true是错误的，以及最好如何修复这个错误 (最后， <a href="https://docs.python.org/3/whatsnew/3.5.html#changes-in-the-python-api" target="_blank" rel="external">在Python 3.5中移除</a>了<code>__bool__()</code>的实现)。</p>
<p>在面对一个可能的false值时，如果你发现自己需要提供一个特定的默认值，那么使用<code>or</code>将是有帮助的。<code>and</code>和<code>or</code>都不返回一个特定的布尔值，而是返回第一个确定为true值的值。对于<code>or</code>，如果它的第一个值是true，则返回第一个值，否则返回第二个值，无论第二个值是什么。这意味着，如果像这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Use the value from something() if it is true, else default to None.</span></div><div class="line">spam = something() <span class="keyword">or</span> <span class="keyword">None</span></div></pre></td></tr></table></figure>
<p>那么，如果<code>something()</code>是true，那么<code>spam</code>将获得<code>something()</code>的返回值，否则将会被设为<code>None</code>。并且，因为<code>and</code>和<code>or</code>都是短路的，所以你可以将其与一些对象实例组合在一起，并知道除非必要，否则不会发生；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Only execute AnotherThing() if something() returns a false value.</span></div><div class="line">spam = something() <span class="keyword">or</span> AnotherThing()</div></pre></td></tr></table></figure>
<p>不会执行<code>AnotherThing()</code>，除非<code>something()</code>返回一个false值。</p>
<p>最后，在可能的时候，确保使用<a href="https://docs.python.org/3/library/functions.html#any" target="_blank" rel="external"><code>any()</code></a>和<a href="https://docs.python.org/3/library/functions.html#all" target="_blank" rel="external"><code>all()</code></a>。这些内建函数在需要的时候是非常方便的，而将它们与生成器表达式组合使用，则是相当强大的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://lsqpyer.github.io/2017/03/17/更好的Python对象序列化方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="尋覓">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.bmp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="尋覓">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/17/更好的Python对象序列化方法/" itemprop="url">
                  更好的Python对象序列化方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-17T10:52:43+08:00">
                2017-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文：<a href="https://hynek.me/articles/serialization/" target="_blank" rel="external">Better Python Object Serialization</a></p>
<hr>
<p>Python标准库充满了蒙尘的宝石。其中一个允许基于参数类型的简单优雅的函数调度。这使得它对任意对象的序列化是完美的 —— 例如，web API和结构化日志的JSON化。</p>
<p>谁没有看过它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">TypeError: datetime.datetime(...) <span class="keyword">is</span> <span class="keyword">not</span> JSON serializable</div></pre></td></tr></table></figure>
<p>虽然这应该不是一个大问题，但是它是。<code>json</code>模块 —— 从<code>simplejson</code>继承了其API —— 提供了两种序列化对象的方法：</p>
<ol>
<li>实现一个<code>default()</code> <em>函数</em>，该函数接收一个对象，然后返回<a href="https://docs.python.org/3/library/json.html#json.JSONEncoder" target="_blank" rel="external"><code>JSONEncoder</code></a>能够理解的东东。</li>
<li>自己实现或子类化<code>JSONEncoder</code>，然后将其当做<code>cls</code>传递给dump方法。你可以自己实现它，或者重载<code>JSONEncoder.default()</code> <em>方法</em>。</li>
</ol>
<p>而由于替代实现想要混进去，所以它们不同程度地模仿了<code>json</code>模块的API。[1]</p>
<h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><p>这两种方法的共同点是，它们是不可扩展的：未提供新类型的添加支持。你单一的<code>default()</code>备用必须知道所有你想要序列化的类型。这意味着你要么写像这样的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_serializable</span><span class="params">(val)</span>:</span></div><div class="line">    <span class="keyword">if</span> isinstance(val, datetime):</div><div class="line">        <span class="keyword">return</span> val.isoformat() + <span class="string">"Z"</span></div><div class="line">    <span class="keyword">elif</span> isinstance(val, enum.Enum):</div><div class="line">        <span class="keyword">return</span> val.value</div><div class="line">    <span class="keyword">elif</span> attr.has(val.__class__):</div><div class="line">        <span class="keyword">return</span> attr.asdict(val)</div><div class="line">    <span class="keyword">elif</span> isinstance(val, Exception):</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="string">"error"</span>: val.__class__.__name__,</div><div class="line">            <span class="string">"args"</span>: val.args,</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">return</span> str(val)</div></pre></td></tr></table></figure>
<p>这很痛苦，因为你必须在同一个地方为所有对象添加序列化。[2]</p>
<p>或者，你可以尝试自己拿出解决方案，就如Pyramid的JSON渲染器在<a href="http://docs.pylonsproject.org/projects/pyramid/en/latest/narr/renderers.html#using-the-add-adapter-method-of-a-custom-json-renderer" target="_blank" rel="external"><code>JSON.add_adapter</code></a>中做的那样，它使用了待在冷宫中的<code>zope.interface</code>的适配器注册表。[3]</p>
<p>另一方面，Django使用了一个<code>DjangoJSONEncoder</code>来解决，这是<code>json.JSONEncoder</code>的一个子类，并且它知道如何解码日期、时间、UUID，并保证（可以）。但除此之外，你又要靠自己了。如果你想更进一步使用Django和web API，那么，反正你可能已经使用Django REST框架了。它们提出了一个完整的<a href="http://www.django-rest-framework.org/api-guide/serializers/" target="_blank" rel="external">序列化系统</a>，这个系统可不仅仅做了让数据准备好<code>json.dumps()</code>。</p>
<p>最后，为了完整起见，我觉得我必须提一提自己在<a href="http://www.structlog.org/en/stable/" target="_blank" rel="external"><code>structlog</code></a>的解决方法，这一方法从一开始我就深深地讨厌：添加一个<code>__structlog__</code>方法到你的类中，它按照<code>__str__</code>返回一个序列化表示。请不要重蹈我的覆辙；标签 <a href="https://softwareclown.com" target="_blank" rel="external">软件小丑</a>。</p>
<hr>
<p>鉴于JSON相当普遍，令人惊讶的是，目前，我们只有孤立的解决方案。我个人希望的是，有一种方法，可以在一个地方统一注册序列器，但是以一种分散的方式，而无需对我的（或者更糟糕：第三方）类进行任何改变。</p>
<h2 id="进入PEP-443"><a href="#进入PEP-443" class="headerlink" title="进入PEP 443"></a>进入PEP 443</h2><p>原来，对这个问题，Python 3.4想出了一个很好的解决方法，参见<a href="https://www.python.org/dev/peps/pep-0443/" target="_blank" rel="external">PEP 443</a>: <a href="https://docs.python.org/3/library/functools.html#functools.singledispatch" target="_blank" rel="external"><code>functools.singledispatch</code></a> (对于Python遗留版本，也可见<a href="https://pypi.org/project/singledispatch/" target="_blank" rel="external">PyPI</a>)。</p>
<p>简单地说，定义一个默认的函数，然后基于第一个参数类型，注册该函数的额外版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</div><div class="line"></div><div class="line"><span class="meta">@singledispatch</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_serializable</span><span class="params">(val)</span>:</span></div><div class="line">    <span class="string">"""Used by default."""</span></div><div class="line">    <span class="keyword">return</span> str(val)</div><div class="line">    </div><div class="line"><span class="meta">@to_serializable.register(datetime)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ts_datetime</span><span class="params">(val)</span>:</span></div><div class="line">    <span class="string">"""Used if *val* is an instance of datetime."""</span></div><div class="line">    <span class="keyword">return</span> val.isoformat() + <span class="string">"Z"</span></div></pre></td></tr></table></figure>
<p>现在，你也可以在<code>datetime</code>实例上调用<code>to_serializable()</code>，而单一的调度将选择正确的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(&#123;<span class="string">"msg"</span>: <span class="string">"hi"</span>, <span class="string">"ts"</span>: datetime.now()&#125;,</div><div class="line"><span class="meta">... </span>           default=to_serializable)</div><div class="line"><span class="string">'&#123;"ts": "2016-08-20T13:08:59.153864Z", "msg": "hi"&#125;'</span></div></pre></td></tr></table></figure>
<p>这给了你将你的序列器改造成你所想要的权力：和类一起，在一个单独的模块，或者和JSON相关的代码放在一起？任君选择！但是你的<em>类</em>保持干净，你的项目之间没有庞大的<code>if-elif-else</code>分支。</p>
<h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><p>显然，<code>@singledispatch</code>的适用范围不仅是JSON。一般的绑定不同行为到不同类型上 ，以及特别的对象序列化是普遍有用的[4]。我的一些校对人员提到，他们使用在可调用对象上使用类的<code>dict</code>，尝试了贫民窟近似和其他类似的暴行。(Ele注，原文是“Some of my proofreaders mentioned they tried a ghetto approximation using dicts of classes to callables and other similar atrocities.”。有更好的翻译，欢迎贡献~~)</p>
<p>换句话说，<code>@singledispatch</code>只可能是那个你一直想要的函数，虽然它一直都在。</p>
<p>P.S. 当然，在<a href="https://pypi.org/project/multipledispatch/" target="_blank" rel="external">PyPI</a>上，还有一个<code>*multiple*dispatch</code>。</p>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><hr>
<ol>
<li>然而，有个流行的替代实现：<a href="https://github.com/esnme/ultrajson" target="_blank" rel="external">UltraJSON</a>完全不支持自定义对象序列化，而<a href="https://github.com/kenrobbins/python-rapidjson" target="_blank" rel="external"><code>python-rapidjson</code></a>只支持<code>default()</code>函数。</li>
<li>虽然你可以看到，使用<code>attrs</code>可管理；也许<a href="https://glyph.twistedmatrix.com/2016/08/attrs.html" target="_blank" rel="external">你应该使用<code>attrs</code></a>! </li>
<li>不幸的是，在从<a href="https://docs.zope.org/zope.component/" target="_blank" rel="external"><code>zope.component</code></a>移植过来后，当前API Pyramid的使用是<a href="https://github.com/zopefoundation/zope.interface/issues/41" target="_blank" rel="external">无正式文档的</a>。</li>
<li>有人告诉我，添加单一调度到标准库的原始动力是<a href="https://docs.python.org/3.5/library/pprint.html" target="_blank" rel="external"><code>pprint</code></a> 的一个更加优雅的重新实现(从未发生过)。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://lsqpyer.github.io/2017/03/17/为部署Python web应用程序构建一个更好的用户体验/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="尋覓">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.bmp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="尋覓">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/17/为部署Python web应用程序构建一个更好的用户体验/" itemprop="url">
                  为部署Python web应用程序构建一个更好的用户体验
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-17T10:51:42+08:00">
                2017-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文：<a href="http://blog.dscpl.com.au/2016/02/building-better-user-experience-for.html" target="_blank" rel="external">Building a better user experience for deploying Python web applications.</a></p>
<hr>
<p>我又一次错过了一个在PyCon US谈话的机会。我想谈的题目与这篇博客文章是一样的。由于它不被接受，所以我想我可能会转而使用一篇博文来一瞥我一直在做的Python Web应用程序部署的最近的工作，而如果它被接受，我本来会在我的谈话中描述一下相关内容。</p>
<p>对于那些可能已经跟随我在过去一直在做的，使用Apache和mod_wsgi来为运行着的Python web应用程序创建和运用Docker图像的人，这是工作的进展，扩大范围，并使它在Docker容器外可用。</p>
<h1 id="使用Django示范"><a href="#使用Django示范" class="headerlink" title="使用Django示范"></a>使用Django示范</h1><p>为了说明这是怎么一回事，下面是一个简单的演示。其中，创建了一个新的Django web应用程序项目，并让它运行。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; $ django-admin startproject mydjangosite</div><div class="line">&gt; $ cd mydjangosite/</div><div class="line">&gt; $ python manage.py runserver</div><div class="line">&gt; Performing system checks...</div><div class="line">&gt; System check identified no issues (<span class="number">0</span> silenced).</div><div class="line">&gt; You have unapplied migrations; your app may <span class="keyword">not</span> work properly until they are applied.</div><div class="line">&gt; Run <span class="string">'python manage.py migrate'</span> to apply them.</div><div class="line">&gt; February <span class="number">18</span>, <span class="number">2016</span> - <span class="number">01</span>:<span class="number">22</span>:<span class="number">25</span></div><div class="line">&gt; Django version <span class="number">1.9</span><span class="number">.2</span>, using settings <span class="string">'mydjangosite.settings'</span></div><div class="line">&gt; Starting development server at http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>/</div><div class="line">&gt; Quit the server <span class="keyword">with</span> CONTROL-C.</div></pre></td></tr></table></figure></p>
<p>这里没有什么特别的，而如果我们访问URL“<a href="http://127.0.0.1:8000/admin”，我们将看到Django管理界面的登录页面。由于我们使用的是内置Django开发服务器，所以登录页面的样式看起来正确的，因为开发服务器自动处理静态文件资产，例如样式表。" target="_blank" rel="external">http://127.0.0.1:8000/admin”，我们将看到Django管理界面的登录页面。由于我们使用的是内置Django开发服务器，所以登录页面的样式看起来正确的，因为开发服务器自动处理静态文件资产，例如样式表。</a></p>
<p>正如你应该都希望知道的，Django开发服务器不应该被用于生产系统。但至少对于开发，由于它处理静态文件资产，同时还提供动态代码加载，因此开发服务器是很方便的。虽然开发服务器的使用会隐藏只会发生在生产环境中（其中可能使用一个多进程和/或多线程结构）的某些问题。</p>
<p>建立一个生产级Web服务器通常被视为是一个很大的麻烦，人们可以与之斗争。因此，让我们看看我们是否能够使之更容易一些。</p>
<h1 id="简化的web应用程序包装"><a href="#简化的web应用程序包装" class="headerlink" title="简化的web应用程序包装"></a>简化的web应用程序包装</h1><p>为了创建上面的Django应用程序，首先需要安装Django。这很简单，只是以便‘django-admin’程序可用。试想一下，虽然我并不需要它，因为我曾手工创建该项目的骨架，或已签出一个现有的Django项目库。为了强调这一点，让我们使用’virtualenvwrapper“创建一个新的Python虚拟环境。其中，我要安装一个名为“WarpDrive”的Python包。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt; $ mkvirtualenv warpdrive</div><div class="line">&gt; New python executable <span class="keyword">in</span> /Users/graham/Python/warpdrive/bin/python</div><div class="line">&gt; Installing setuptools, pip, wheel...done.</div><div class="line">&gt; virtualenvwrapper.user_scripts creating /Users/graham/Python/warpdrive/bin/predeactivate</div><div class="line">&gt; virtualenvwrapper.user_scripts creating /Users/graham/Python/warpdrive/bin/postdeactivate</div><div class="line">&gt; virtualenvwrapper.user_scripts creating /Users/graham/Python/warpdrive/bin/preactivate</div><div class="line">&gt; virtualenvwrapper.user_scripts creating /Users/graham/Python/warpdrive/bin/postactivate</div><div class="line">&gt; virtualenvwrapper.user_scripts creating /Users/graham/Python/warpdrive/bin/get_env_details</div><div class="line">&gt; </div><div class="line">&gt; (warpdrive) $ pip install warpdrive</div><div class="line">&gt; Collecting warpdrive</div><div class="line">&gt; Installing collected packages: warpdrive</div><div class="line">&gt; Successfully installed warpdrive-0.14.6</div></pre></td></tr></table></figure>
<p>我们仍然需要Django，但我们绝对不希望在命令行上将其作为参数传递给’pip’以进行手动安装。相反，我们应该为”pip”在‘requirements.txt’文件中任何需要的Python包。因此，我们将创建一个“requirements.txt”，并在文件中只列出”Django。</p>
<p>即使到现在，我仍然没有真的想要手动运行‘pip’来建立一个Python Web应用程序项目，这样的话，它可以比安装必需的Python包更频繁的运行。例如，当与一个生产级WSGI服务器一起使用Django时，它一般会需要运行’python manage.py collectstatic’。这些措施虽然可能被用户遗忘。更好的方法是自动完成这样的步骤，并在必要时，将这些手动步骤记录在特殊的构建脚本中，这样，在为运行一个Python Web应用程序设置环境时，就可以自动运行。这就是‘warpdrive’发挥的作用。</p>
<p>现在，虽然我创建了一个Python虚拟环境，并安装了‘warpdrive’，但是它很干净，所以我安装了‘warpdrive’并显示它，否则我只是安装了一个空的Python。</p>
<p>我现在要做的事是为这个特定的Python Web应用程序建立一个单独的Python虚拟环境，但是让‘warpdrive’为我创建并设置它。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; (warpdrive) $ eval "$(warpdrive activate mydjangosite)" </div><div class="line">&gt; (warpdrive+mydjangosite) $ warpdrive build</div><div class="line">&gt;  -----&gt;; Installing dependencies with pip</div><div class="line">&gt; Collecting Django (from -r requirements.txt (line 1))</div><div class="line">&gt;  Downloading Django-1.9.2-py2.py3-none-any.whl (6.6MB)</div><div class="line">&gt;  100% |████████████████████████████████| 6.6MB 1.4MB/s</div><div class="line">&gt; Installing collected packages: Django</div><div class="line">&gt; Successfully installed Django-1.9.2</div><div class="line">&gt; Collecting mod-wsgi</div><div class="line">&gt; Installing collected packages: mod-wsgi</div><div class="line">&gt; Successfully installed mod-wsgi-4.4.22</div><div class="line">&gt;  -----&gt;; Collecting static files for Django</div><div class="line">&gt; Copying ‘.../django/contrib/admin/static/admin/css/base.css’</div><div class="line">&gt; ...</div><div class="line">&gt; </div><div class="line">&gt; 56 static files copied to '/Users/graham/.warpdrive/warpdrive+mydjangosite/home/django_static_root'.</div></pre></td></tr></table></figure>
<p>这里的第一步是使用‘warpdrive activate’创建一个新的Python虚拟环境，并将其用于当前的shell。第二步是使用‘warpdrive build’来设置我们的环境。</p>
<p>‘warpdrive build’命令在这里做一些事情，但主要的事情是，它安装在‘requirements.txt’ 文件中列出的所有Python包，安装‘mod_wsgi-express’，最后运行‘python manage.py collectstatic’。</p>
<p>你可能注意到，我们实际上并没有指定Django管理命令‘collectstatic’应该被执行。这是因为‘warpdrive’本身知道了Python Web应用程序可能会启动的各种方式，包括当你运行一个Django web应用程序时检测的特殊支持。知道你正在使用Django，它就会自动为你运行‘collectstatic’。</p>
<p>敏锐的人甚至可能会注意到，我们没有修改Django的设置模块，并指定‘STATIC_ROOT’从而使得“collectstatic”知道从哪里拷贝静态文件资产。再次，这是‘warpdrive’的聪明之处，它意识到当运行‘collectstatic’时，并没有为它定义‘STATIC_ROOT’，因此它会用它自己的‘STATIC_ROOT’值来代替。</p>
<p>当你接着更改静态文件资产或修改‘requirements.txt’文件时，你只需要重新运行‘warpdrive build’来刷新当前环境。</p>
<p>随着Web应用程序的环境的构建，现在我们可以启动它了。要做到这一点，我们将使用‘warpdrive start’。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&gt; (warpdrive+mydjangosite) $ warpdrive start</div><div class="line">&gt;  -----&gt;; Configuring for server type of auto</div><div class="line">&gt;  -----&gt;; Running server script start-mod_wsgi</div><div class="line">&gt;  -----&gt;; Executing server command ' mod_wsgi-express start-server --log-to-terminal --startup-log --port 8080 --application-type module --entry-point mydjangosite.wsgi --callable-object application --url-alias /static/ /Users/graham/.warpdrive/warpdrive+mydjangosite/home/django_static_root/'</div><div class="line">&gt; Server URL : http://localhost:8080/</div><div class="line">&gt; Server Root : /tmp/mod_wsgi-localhost:8080:502</div><div class="line">&gt; Server Conf : /tmp/mod_wsgi-localhost:8080:502/httpd.conf</div><div class="line">&gt; Error Log File : /dev/stderr (warn)</div><div class="line">&gt; Startup Log File : /dev/stderr</div><div class="line">&gt; Request Capacity : 5 (1 process * 5 threads)</div><div class="line">&gt; Request Timeout : 60 (seconds)</div><div class="line">&gt; Queue Backlog : 100 (connections)</div><div class="line">&gt; Queue Timeout : 45 (seconds)</div><div class="line">&gt; Server Capacity : 20 (event/worker), 20 (prefork)</div><div class="line">&gt; Server Backlog : 500 (connections)</div><div class="line">&gt; Locale Setting : en_AU.UTF-8</div><div class="line">&gt; [Thu Feb 18 12:58:37.279748 2016] [mpm_prefork:notice] [pid 9456] AH00163: Apache/2.4.16 (Unix) mod_wsgi/4.4.22 Python/2.7.10 configured -- resuming normal operations</div><div class="line">&gt; [Thu Feb 18 12:58:37.280085 2016] [core:notice] [pid 9456] AH00094: Command line: 'httpd (mod_wsgi-express) -f /tmp/mod_wsgi-localhost:8080:502/httpd.conf -E /dev/stderr -D FOREGROUND'</div></pre></td></tr></table></figure>
<p>与之前不同，这次，Django开发服务器并没有运行。相反，‘warpdrive’会运行‘mod_wsgi-express’。在此过程中，已经从Django应用本身自动决定WSGI应用程序入口点是什么，静态文件资产挂载在哪里，以及确定静态文件资产位于何处。因此，我们用于Django管理页面的样式表可以工作，即使你已经忘了在Django配置文件中设置“STATIC_ROOT”，因为‘warpdrive’会检测到。</p>
<p>没有真正额外的工作，我们已经有了自己生产级别的WSGI服务器，从而可以更加自信，当我们真正部署我们的Django应用程序时，我们有更多的东西可比较。理论上，这甚至可以被用作生产部署的基础，如果是的话，这意味着你的本地环境将尽可能接近实际生产平台。</p>
<p>至于其他配置或安装步骤，‘warpdrive’支持执行钩子脚本（可作为构建和部署阶段的一部分执行）的各种机制。这意味着你可以捕捉设置步骤，并在适当情况下，同时在本地环境和生产环境上触发它们。也可提供附加的WSGI服务器选项或环境变量来覆盖或定制结构，诸如调谐正在使用的进程和线程的数目。</p>
<p>一个有关本地开发的特定环境变量是“MOD_WSGI_RELOAD_ON_CHANGES”。运行‘warpdrive start’时定义这个变量，而恢复内置的Django开发服务器的自动代码加载功能，意味着你也可以在开发过程中容易地使用‘warpdrive’。</p>
<h1 id="那个名为Docker的酷小孩"><a href="#那个名为Docker的酷小孩" class="headerlink" title="那个名为Docker的酷小孩"></a>那个名为Docker的酷小孩</h1><p>你可能会说，但我用Docker，所以这是将怎么帮助我呢。</p>
<p>这是没有问题的，‘warpdrive’实际上产生于我一直在使用Docker做的所有工作。你可以在技术上建立自己的Docker基本图形，并假设它满足关于特定的可用系统包的一些要求，从你的‘Dockerfile’中触发‘warpdrive build’，以及从‘CMD’中触发‘warpdrive start’。</p>
<p>虽然较容易的方法是使用Docker基本图形，也就是我所创建的已经包含所有必需的基本包和整合‘warpdrive’的那个。</p>
<p>虽然必须自己创建Docker图形仍然很痛苦，尤其是从头做起，而你不知道在此过程中所有的陷阱。</p>
<p>为了使这一切变得更容易，我有的‘warpdrive’和Docker基本图像已经启用S2I。</p>
<p>最有可能的是，你没有听说过S2I，但它所代表的是“从源到图像”。它由一些托管服务实现，加强了构建包的概念，但重新想象和现代化了Docker的使用。</p>
<p>你可以在这里读到更多关于“从源到图像”的内容：</p>
<ul>
<li><a href="https://github.com/openshift/source-to-image" target="_blank" rel="external">https://github.com/openshift/source-to-image</a></li>
</ul>
<p>我的Django Web应用程序已运行，要为它创建一个Docker图像，我现在所要做的是运行‘warpdrive s2i’。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; (warpdrive+mydjangosite) $ warpdrive s2i</div><div class="line">&gt; ---&gt;; Installing application source</div><div class="line">&gt; ---&gt;; Building application from source</div><div class="line">&gt; -----&gt;; Installing dependencies with pip</div><div class="line">&gt; Collecting Django (from -r requirements.txt (line 1))</div><div class="line">&gt; Downloading Django-1.9.2-py2.py3-none-any.whl (6.6MB)</div><div class="line">&gt; Installing collected packages: Django</div><div class="line">&gt; Successfully installed Django-1.9.2</div><div class="line">&gt; -----&gt;; Collecting static files for Django</div><div class="line">&gt; Copying ‘.../django/contrib/admin/static/admin/img/icon-yes.svg’</div><div class="line">&gt; ...</div><div class="line">&gt; </div><div class="line">&gt; 56 static files copied to '/home/warpdrive/django_static_root'.</div><div class="line">&gt; ---&gt;; Fix permissions on application source</div><div class="line">&gt; (warpdrive+mydjangosite) $ docker images | grep mydjangosite</div><div class="line">&gt; warpdrive-mydjangosite latest 8d7fd16f7ab8 20 seconds ago 819.6 MB</div></pre></td></tr></table></figure>
<p>这样做的结果是结合我的Django web应用程序及其所需的Docker图像，它叫做warpdrive-mydjangosite’。和以前一样，作为Docker图像生成阶段的一部分，‘collectstatic’被自动运行。</p>
<p>那么，运行Docker图像只是执行‘docker run’，并暴露适当的端口的问题。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; (warpdrive+mydjangosite) $ docker run -p 8080:8080 warpdrive-mydjangosite</div><div class="line">&gt; ---&gt;; Executing the start up script</div><div class="line">&gt;  -----&gt;; Configuring for server type of auto</div><div class="line">&gt;  -----&gt;; Running server script start-mod_wsgi</div><div class="line">&gt;  -----&gt;; Executing server command ' mod_wsgi-express start-server --log-to-terminal --startup-log --port 8080 --application-type module --entry-point mydjangosite.wsgi --callable-object application --url-alias /static/ /home/warpdrive/django_static_root/'</div><div class="line">&gt; [Thu Feb 18 03:08:22.406961 2016] [mpm_event:notice] [pid 19:tid 139789921310464] AH00489: Apache/2.4.18 (Unix) mod_wsgi/4.4.22 Python/2.7.11 configured -- resuming normal operations</div><div class="line">&gt; [Thu Feb 18 03:08:22.407345 2016] [core:notice] [pid 19:tid 139789921310464] AH00094: Command line: 'httpd (mod_wsgi-express) -f /tmp/mod_wsgi-localhost:8080:1001/httpd.conf -E /dev/stderr -D MOD_WSGI_MPM_ENABLE_EVENT_MODULE -D MOD_WSGI_MPM_EXISTS_EVENT_MODULE -D MOD_WSGI_MPM_EXISTS_WORKER_MODULE -D MOD_WSGI_MPM_EXISTS_PREFORK_MODULE -D FOREGROUND'</div></pre></td></tr></table></figure>
<p>然后，你可以进一步测试在Docker上下文中运行的web应用程序，而如果结果令你满意，你可以推送该Docker图像到你的托管平台，并运行它。</p>
<h1 id="部署到OpenShift-3"><a href="#部署到OpenShift-3" class="headerlink" title="部署到OpenShift 3"></a>部署到OpenShift 3</h1><p>如果使用基于Docker和Kubernetes的OpenShift最新版本，部署更容易。这是因为你不需要自己通过单独的步骤去创建Docker图像并将其上传到Docker注册表。这是因为OpenShift本身知道从源到图像，并可以直接从一个Gi​​t仓库部署Web应用程序。</p>
<p>要部署同样的应用程序到OpenShift，所有我需要做的就是提交我的修改，并推动它们到了我的Git仓库，然后运行：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt; (warpdrive+mydjangosite) $ oc new-app grahamdumpleton/warp0-debian8-python27~https://github.com/GrahamDumpleton/django-hello-world-v1.git</div><div class="line">&gt; --&gt;; Found Docker image d148eec (8 hours old) from Docker Hub for "grahamdumpleton/warp0-debian8-python27"</div><div class="line">&gt; Python 2.7 (Warp Drive)</div><div class="line">&gt;  -----------------------</div><div class="line">&gt;  S2I builder for Python web applications.</div><div class="line">&gt; Tags: builder, python, python27, warpdrive, warpdrive-python27</div><div class="line">&gt; * An image stream will be created as "warp0-debian8-python27:latest" that will track the source image</div><div class="line">&gt;  * A source build using source code from https://github.com/GrahamDumpleton/django-hello-world-v1.git will be created</div><div class="line">&gt;  * The resulting image will be pushed to image stream "django-hello-world-v1:latest"</div><div class="line">&gt;  * Every time "warp0-debian8-python27:latest" changes a new build will be triggered</div><div class="line">&gt;  * This image will be deployed in deployment config "django-hello-world-v1"</div><div class="line">&gt;  * Port 8080/tcp will be load balanced by service "django-hello-world-v1"</div><div class="line">&gt;  * Other containers can access this service through the hostname "django-hello-world-v1"</div><div class="line">&gt; --&gt;; Creating resources with label app=django-hello-world-v1 ...</div><div class="line">&gt;  imagestream "django-hello-world-v1" created</div><div class="line">&gt;  buildconfig "django-hello-world-v1" created</div><div class="line">&gt;  deploymentconfig "django-hello-world-v1" created</div><div class="line">&gt;  service "django-hello-world-v1" created</div><div class="line">&gt; (warpdrive+mydjangosite) $ oc expose service django-hello-world-v1</div><div class="line">&gt; route "django-hello-world-v1" exposed</div></pre></td></tr></table></figure>
<p>OpenShift将在必要的时候自动下载我的​​带有S2I支持的Docker基本图像S2I支持，以及包含我的应用程序源代码的Git仓库，引发S2I构建过程创建最终的Docker图像，然后进行部署。然后，我们只需要运行最后一步来实际上使Web应用程序可以被公开访问，这样我们就做完了。</p>
<h1 id="备选的PaaS提供商"><a href="#备选的PaaS提供商" class="headerlink" title="备选的PaaS提供商"></a>备选的PaaS提供商</h1><p>‘warpdrive’可以与其他PaaS提供商一起用吗？</p>
<p>答案是肯定的，只要在构建和部署阶段，他们不完全锁定你，并且不要过多搞砸了Python环境。我还没有为此调整‘warpdrive’，并且也许不会，但我已经部署所有这些工作的以前迭代到OpenShift 2和Heroku上了。</p>
<p>最终的结果是，我们在这里有一个可能性，就是使得一个部署可以与多个主机服务一起工作，但仍然可以在你的本地开​​发平台上使用。</p>
<h1 id="备选的web服务器"><a href="#备选的web服务器" class="headerlink" title="备选的web服务器"></a>备选的web服务器</h1><p>在我们的样例应用中，我们使用了Django，但是如果使用给一个备选的WSGI框架，你只需要在你的项目的顶级目录中的‘wsgi.py’文件中应用一个WSGI应用入口点。</p>
<p>默认情况下，‘warpdrive’的‘auto’模式将使用‘mod_wsgi-express’来处理任何WSGI应用，包括Django特定应用。这是因为，‘mod_wsgi-express’的主要目的是为这种类型的部署步骤所构建的。因此，这是可用的最佳选项。</p>
<p>当配置恰当时，大多数WSGI服务器的性能或多或少是相同的。如果你仍然因为某个WSGI服务器的特性能够更好的满足你的web应用的特殊需求而希望使用一个不同的WSGI服务器，那么你可以仍旧使用那个备选的WSGI服务器。要做到这点，你只需要重写‘auto’模式，然后配置你想要使用的WSGI服务器。</p>
<p>所支持的备选WSGI服务器是‘gunicorn’, ‘uwsgi’和‘waitress’。在选择这些时，你只需要确保在用于“pip”的‘requirements.txt’文件中列出它们。一旦你这样做了，‘warpdrive’将会为你用那个WSGI服务器取而代之，运用所需的最小集选项来使它们监听HTTP连接的正确端口，并将在终端保存日志。其他任何确保WSGI服务器可以在一个Docker容器中正常工作的必选项也将在需要的时候应用。</p>
<p>与指定这些任何一个备选WSGI服务器相同，你也可以显式指定应该使用的‘mod_wsgi’。虽然要注意，覆盖部署机制并且不使用‘auto’意味着该WSGI服务器的配置完全取决于你。所以，如果显式指定‘mod_wsgi’或备选WSGI服务器，你会需要告诉它如何使用你的Django应用，反之，‘auto’模式会帮你做好这一切。</p>
<p>对于那些实际上不想使用WSGI服务器，而想要使用其他诸如Tornado web服务器的人，你可以应用一个‘app.py’文件来代替。如果这个文件存在了，那么它会获得优先权，而‘warpdrive’将把它作为一个Python脚本执行，从而运行你的Python web应用。然后，你的web应用只需要监听正确的HTTP端口即可。</p>
<p>想要更多关于启动的控制权，你也可以运用一个‘app.sh’文件，在其中执行任何必要的步骤或者设置特殊的环境变量。关于这点唯一必要条件是，在shell脚本中运行实际的web应用的最后的命令要使用‘exec’，这样的话，该web应用才能替代shell进程。这是要确保当在Docker下运行时，信号正确工作。例如，当想要安装和运行Jupyter Notebook时，你可能会使用一个‘app.sh’文件</p>
<p>如果其他Python web框架的特殊知识具有一个唯一且常用的部署方法，那么它们也可以被添加。例如，‘warpdrive’也将识别一个‘paste.ini’文件（它可能被基于Paste的web应用使用），然后配置和启动‘mod_wsgi-express’来运行它。</p>
<h1 id="你应该用它吗"><a href="#你应该用它吗" class="headerlink" title="你应该用它吗?"></a>你应该用它吗?</h1><p>现在，‘warpdrive’就是我的玩具。</p>
<p>由于用户对项目开发者的要求，将新的开源项目带到公众面前是危险的。</p>
<p>所以现在，你可能不想要使用它，因为我仍然想要可以灵活地根据我想要的对它的工作方式进行修改。另外，我真的不想要成堆的用户用简单的问题纠缠我。</p>
<p>我曾经说它已准备好使用吗?可能会，可能不会。这取决于是否有任何兴趣。令人吃惊的是，过去，从这整个概念的某些部分中，我已经获得了一些既成事实(原文是：I have gotten a fait bit of push back from some quarters on this whole concept in the past.想不到确切的译法，SOS！T_T)。这很可能是少数人，他们认为他们已经知道自己如何做这一切了，但是这样消极的反应并不有助于将此想法公布于众并使之可用。</p>
<p>如果你受我所呈现的东西所启发，认为它有价值，并且你可能使用的它，那么至少在Twitter上关注我（@GrahamDumpleton），然后在Twitter上让我知道你的想法。谢谢。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://lsqpyer.github.io/2017/03/17/Requests vs. urllib：它解决了什么问题？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="尋覓">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.bmp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="尋覓">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/17/Requests vs. urllib：它解决了什么问题？/" itemprop="url">
                  Requests vs. urllib：它解决了什么问题？
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-17T10:51:00+08:00">
                2017-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文：<a href="http://www.curiousefficiency.org/posts/2016/08/what-problem-does-it-solve.html" target="_blank" rel="external">What problem does it solve?</a></p>
<hr>
<p>对于Python新手来说，Python较令人费解的方面之一就是，当涉及到编写HTTP(S)协议客户端时，标准库的<code>urllib</code>模块和流行的（及备受推崇的）第三方模块<code>requests</code>之间鲜明的可用性差异。当你的问题是“与HTTP服务器进行通信”时，可用性方面的差异并不是那么明显，但一涉及到额外的需求，像SSL/TLS、鉴权、重定向处理、会话管理和JSON请求/响应主题，差异就明显起来。</p>
<p>想要<a href="http://noamelf.com/2016/08/05/designing-pythonic-apis/" target="_blank" rel="external">记录易用性的差异</a>是诱人而完全可以理解的，直到<code>requests</code>是”Pythonic” (在2016年), 而<code>urllib</code>现在已经不Pythonic了 (尽管被包含在了标准库中)。</p>
<p>虽然当然有那么点因素(例如，内置的<code>property</code>是在Python 2.2才添加进来的，而<code>urllib2</code>被包含在原始的Python 2.0发布中，因此在其API设计中无法考虑这点)，但是绝大多数的可用性差异涉及到了我们经常忘记问问所使用的软件的一个完全不同的问题：<em>它解决了什么问题？</em></p>
<p>即，<code>urllib</code>/<code>urllib2</code>和<code>requests</code>之间的许多令人惊讶的其他差异可以由它们<em>解决不同的问题</em>这一事实，以及较之于Jeremy Hylton在十年前想要解决的问题，现今大多数HTTP客户端开发者所遇到的问题更接近于Kenneth Reitz在2010/2011年设计<code>requests</code>用以解决的问题来解释。</p>
<h3 id="答案都在名字里了"><a href="#答案都在名字里了" class="headerlink" title="答案都在名字里了"></a>答案都在名字里了</h3><p>引用当前的Python 3 <code>urllib</code>包文档：“urllib是一个收集几个处理URL模块的包”。</p>
<p>以及来自Jeremy的添加<code>urllib2</code>到CPython的<a href="https://hg.python.org/cpython/rev/b800e36aed4e" target="_blank" rel="external">原始提交信息</a>的文档字符串：“使用各种协议，用于打开URL的可扩展库”。</p>
<p>等等，神马？我们只是想写一个HTTP客户端，所以为什么文档谈到一般的URL相关工作？</p>
<p>虽然，对于那些习惯于现代的HTTPS+JSON驱动的交互式web的开发者来说有点奇怪，但是事情为什么会变成这样并不总是清晰的。</p>
<p>在世纪之交，所期望的是，保留丰富多样的数据传输协议，并且为不同的目的进行不同的特点优化，而标准库中最为有用的客户端则是那个可以用来与多种不同类型的服务器（例如HTTP, FTP, NFS等等）进行通信，客户端开发者无需过多担心使用的特定的协议（由URL schema所示）。</p>
<p>然而，在实践中，事情并非如此（大多数是因为严格的防火墙制度，这意味着HTTP服务器是唯一一个可被可靠访问的远程服务），所以，在2016年，人们现在经常拿专用的仅HTTP(S)客户端库的可用性和在获取大多数HTTP(S)特性之前需要专门配置使用HTTP(S)的通用的URL处理库进行比较。</p>
<p>在编写它的时候，<code>urllib2</code>是被设计来适合“通用URL处理”这一方孔的方钉。相比之下，大多数的现代客户端开发者在寻找适合“HTTPS+JSON处理”这一圆孔的圆钉 —— 如果你先把角磨圆，那么<code>urllib</code>/<code>urllib2</code>就会适用，但<code>requests</code>则已经是圆的了。</p>
<h3 id="所以，为什么不把requests添加到标准库中呢？"><a href="#所以，为什么不把requests添加到标准库中呢？" class="headerlink" title="所以，为什么不把requests添加到标准库中呢？"></a>所以，为什么不把requests添加到标准库中呢？</h3><p>对”它解决了什么问题？”这个不那么明显的问题的回答，会到一个明显得多的后续问题：如果<code>urllib</code>/<code>urllib2</code>被设计来解决的问题不再常见，而<code>requests</code>解决的问题是常见的，那么为什么不把<code>requests</code>添加到标准库中呢？</p>
<p>如果我记得没错，在2013年左右(在<code>requests</code> 1.0发布后)的一次语言提交中，Guido在原则上认可了这个想法，而在核心开发者团队中，无论是<code>requests</code>本身（可能作为一个独立升级组件的捆绑快照），还是带有不一样实现的的API兼容子集，最终都会出现在标准库中，这是一个相当常见的假设。</p>
<p>然而，即使撇开<a href="https://github.com/kennethreitz/requests/issues/2424" target="_blank" rel="external">requests开发者关于此想法的疑惑</a>，让<code>requests</code>作为标准库组件的一部分，仍然有一些不一般的系统集成问题要解决。</p>
<p>特别是，其中之一是，requests确实更可靠地以跨平台的方式处理SSL/TLS证书是捆绑包含在<code>certifi</code>项目中的Mozilla证书捆绑（Mozilla<br>Certificate Bundle）。这是默认情况下（由于以跨平台的方式获​得对系统的安全证书的可靠访问的困难）的一个明智之举，但它与标准库的安全策略（具体是将证书管理委托给底层操作系统）相冲突。这项策略的目的是解决两个需求：允许Python应用程序访问添加到系统证书存储的自定义机构证书（最值得注意的是，适用于大型组织的私有CA证书），并避免增加当根证书捆绑出于任何其他原因而改变时，需要更新的额外的证书存储到终端用户系统。</p>
<p>这类问题在技术上是可以解决的，但解决它们并不好玩，并且帮助解决它们的人手头上已经有许许多多其他的要求。这意味着，只要大部分的CPython和<code>requests</code>开发者将其贡献作为业余时间的活动，而不是专门被雇佣来做的事，那么在这个方面我们可能不会看到太多进展。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://lsqpyer.github.io/2017/03/17/设计Pythonic API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="尋覓">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.bmp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="尋覓">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/17/设计Pythonic API/" itemprop="url">
                  设计Pythonic API
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-17T10:50:15+08:00">
                2017-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文：<a href="http://noamelf.com/2016/08/05/designing-pythonic-apis/" target="_blank" rel="external">Designing Pythonic APIs</a></p>
<hr>
<p>当编写一个包（库）的时候，为它提供一个良好的API，几乎与它的功能本身一样重要（好吧，至少你想要让别人使用），但怎么才算一个良好的API呢？在这篇文章中，我将尝试通过比较Requests和Urllib（Python标准库的一部分）在一些经典的HTTP场景的使用，从而提供关于这个问题的一些见解，并看看为什么Requests已经成为了Python用户中的事实上的标准。</p>
<ul>
<li>在我们的探究过程中，我们会使用<strong>Python 3.5</strong>和<strong>Requests 2.10.0</strong>。</li>
</ul>
<p>** 此博文是我上周的一个本地Python聚会（<a href="http://www.meetup.com/PyWeb-IL/events/232724175/" target="_blank" rel="external">PywebIL</a> ）上的演讲的改编。你可以<a href="http://noamelf.com/designing-pythonic-apis-talk" target="_blank" rel="external">在这里</a>找到幻灯片。</p>
<h2 id="requests-vs-urllib"><a href="#requests-vs-urllib" class="headerlink" title="requests vs. urllib"></a><em>requests</em> vs. <em>urllib</em></h2><h3 id="用例1：发送一个GET请求"><a href="#用例1：发送一个GET请求" class="headerlink" title="用例1：发送一个GET请求"></a>用例1：发送一个GET请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> urllib.request</div><div class="line">urllib.request.urlopen(<span class="string">'http://python.org/'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;http.client.HTTPResponse at <span class="number">0x7fdb08b1bba8</span>&gt;</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> requests</div><div class="line">requests.get(<span class="string">'http://python.org/'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;Response [<span class="number">200</span>]&gt;</div></pre></td></tr></table></figure>
<h4 id="显式-API端点-优于隐式"><a href="#显式-API端点-优于隐式" class="headerlink" title="显式(API端点)优于隐式"></a>显式(API端点)优于隐式</h4><ul>
<li>注意到requests对于它要做的事更简洁（因此，更清晰）。</li>
<li><em>urllib</em>被看成隐式发送GET请求，因为它并不接受一个<code>data</code>参数</li>
<li><em>requests</em>函数明确表明它要做什么。</li>
</ul>
<h4 id="有用的对象表示"><a href="#有用的对象表示" class="headerlink" title="有用的对象表示"></a>有用的对象表示</h4><ul>
<li>当检查它的时候，<em>requests</em>返回了一个带有请求状态码的帮助字符串 (通过实现<code>__repr__()</code>方法来完成)。</li>
<li><em>urllib</em>仅仅返回默认的（不清晰的）对象表示</li>
</ul>
<h4 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h4><p>(<a href="https://github.com/kennethreitz/requests/blob/v2.10.0/requests/api.py" target="_blank" rel="external">requests/api.py</a>):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(method, url, **kwargs)</span>:</span></div><div class="line">    <span class="keyword">with</span> sessions.Session() <span class="keyword">as</span> session:</div><div class="line">        <span class="keyword">return</span> session.request(method=method, url=url, **kwargs)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(url, params=None, **kwargs)</span>:</span></div><div class="line">    kwargs.setdefault(<span class="string">'allow_redirects'</span>, <span class="keyword">True</span>)</div><div class="line">    <span class="keyword">return</span> request(<span class="string">'get'</span>, url, params=params, **kwargs)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(url, data=None, json=None, **kwargs)</span>:</span></div><div class="line">    <span class="keyword">return</span> request(<span class="string">'post'</span>, url, data=data, json=json, **kwargs)</div></pre></td></tr></table></figure>
<ul>
<li>所有的HTTP动作在发送之前都遵循相同的流程，因此，有一个<code>request()</code>主流程函数。</li>
<li>为每个调用<code>request()</code>的动作实现一个“辅助函数”，启用我们正在寻找的明确性。</li>
</ul>
<h3 id="用例2：获取请求状态码"><a href="#用例2：获取请求状态码" class="headerlink" title="用例2：获取请求状态码"></a>用例2：获取请求状态码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> urllib.request</div><div class="line">r = urllib.request.urlopen(<span class="string">'http://python.org/'</span>)</div><div class="line">r.getcode()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">200</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> requests</div><div class="line">r = requests.get(<span class="string">'http://python.org/'</span>)</div><div class="line">r.status_code</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">200</span></div></pre></td></tr></table></figure>
<h4 id="无需getter和setter"><a href="#无需getter和setter" class="headerlink" title="无需getter和setter"></a>无需getter和setter</h4><ul>
<li>将对象属性作为实际属性访问（而不是进行方法调用）让代码更清晰些。</li>
<li>如果你是从其他OOP语言过来的 (嗯…… Java)，那么你可能会使用getter和setter，从而允许未来对对象属性进行改变。在Python中不需要这样，仅需使用<a href="http://www.programiz.com/python-programming/property" target="_blank" rel="external"><code>@property</code></a>装饰器。</li>
</ul>
<h4 id="代码片段-1"><a href="#代码片段-1" class="headerlink" title="代码片段"></a>代码片段</h4><p><a href="https://github.com/python/cpython/blob/3.5/Lib/http/client.py#L737" target="_blank" rel="external">http/client.py</a>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTPResponse</span><span class="params">(io.BufferedIOBase)</span>:</span></div><div class="line"></div><div class="line">    <span class="comment"># ...</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getcode</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.status</div></pre></td></tr></table></figure>
<ul>
<li><em>urllib</em> (或实际上是<em>http</em>)使用一个“getter”来返回类属性。</li>
</ul>
<h3 id="用例3：编码、发送和解码POST请求"><a href="#用例3：编码、发送和解码POST请求" class="headerlink" title="用例3：编码、发送和解码POST请求"></a>用例3：编码、发送和解码POST请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> urllib.parse</div><div class="line"><span class="keyword">import</span> urllib.request</div><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line">url = <span class="string">'http://www.httpbin.org/post'</span></div><div class="line">values = &#123;<span class="string">'name'</span> : <span class="string">'Michael Foord'</span>&#125;</div><div class="line"></div><div class="line">data = urllib.parse.urlencode(values).encode()</div><div class="line">response = urllib.request.urlopen(url, data)</div><div class="line">body = response.read().decode()</div><div class="line">json.loads(body)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> requests</div><div class="line"></div><div class="line">url = <span class="string">'http://www.httpbin.org/post'</span></div><div class="line">data = &#123;<span class="string">'name'</span> : <span class="string">'Michael Foord'</span>&#125;</div><div class="line"></div><div class="line">response = requests.post(url, data=data)</div><div class="line">response.json()</div></pre></td></tr></table></figure>
<h4 id="轻松访问常用功能"><a href="#轻松访问常用功能" class="headerlink" title="轻松访问常用功能"></a>轻松访问常用功能</h4><ul>
<li><em>requests</em>为数据编码和加载JSON响应提供了一个开箱即用体验，然而在<em>urllib</em>中，你必须自己实现这些部分。</li>
<li>在设计你的API时考虑：我的包被用的频率多高？我可以添加什么插件，从而使得使用更容易？</li>
</ul>
<p>同时注意，<em>requests</em>还提供了一种优雅的方式来发送JSON内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> requests</div><div class="line"></div><div class="line">url = <span class="string">'http://www.httpbin.org/post'</span></div><div class="line">data = &#123;<span class="string">'name'</span> : <span class="string">'Michael Foord'</span>&#125;</div><div class="line"></div><div class="line">response = requests.post(url, json=data)</div><div class="line">response.json()</div></pre></td></tr></table></figure>
<h3 id="用例4：发送鉴权请求"><a href="#用例4：发送鉴权请求" class="headerlink" title="用例4：发送鉴权请求"></a>用例4：发送鉴权请求</h3><p>下面为HTTP请求创建了持久性凭证，然后发送请求：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> urllib.request</div><div class="line"></div><div class="line">gh_url = <span class="string">'https://api.github.com/user'</span></div><div class="line"></div><div class="line">password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()</div><div class="line">password_mgr.add_password(<span class="keyword">None</span>, gh_url, <span class="string">'user'</span>, <span class="string">'pswd'</span>)</div><div class="line">handler = urllib.request.HTTPBasicAuthHandler(password_mgr)</div><div class="line"></div><div class="line">opener = urllib.request.build_opener(handler)</div><div class="line">opener.open(gh_url)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> requests</div><div class="line"></div><div class="line">session = requests.Session()</div><div class="line">session.auth = (<span class="string">'user'</span>, <span class="string">'pswd'</span>)</div><div class="line">session.get(<span class="string">'https://api.github.com/user'</span>)</div></pre></td></tr></table></figure>
<p>但如果我们只是想进行一次HTTP调用呢？我们需要所有的代码吗？这里，<em>requests</em>允许你这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> requests</div><div class="line"></div><div class="line">requests.get(<span class="string">'https://api.github.com/user'</span>, auth=(<span class="string">'user'</span>, <span class="string">'pswd'</span>))</div></pre></td></tr></table></figure>
<h4 id="为简单和高级使用提供可能性"><a href="#为简单和高级使用提供可能性" class="headerlink" title="为简单和高级使用提供可能性"></a>为简单和高级使用提供可能性</h4><ul>
<li>当发送单个请求，和为多个请求发送一个更详细的请求时，<em>requests</em>允许简洁使用。</li>
<li>当用户需要一个简单的用例时，不要让他经过一个漫长的过程。</li>
</ul>
<h4 id="比起自己创建一个，更喜欢使用Python数据类型"><a href="#比起自己创建一个，更喜欢使用Python数据类型" class="headerlink" title="比起自己创建一个，更喜欢使用Python数据类型"></a>比起自己创建一个，更喜欢使用Python数据类型</h4><ul>
<li><em>requests</em>对Python数据结构的使用使得它非常容易使用。没有必要去了解内部的<em>requests</em>包。</li>
</ul>
<h4 id="库代码"><a href="#库代码" class="headerlink" title="库代码"></a>库代码</h4><p><a href="https://github.com/kennethreitz/requests/blob/v2.10.0/requests/models.py#L488" target="_blank" rel="external">requests/models.py</a>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">prepare_auth</span><span class="params">(self, auth, url=<span class="string">''</span>)</span>:</span></div><div class="line">    <span class="string">"""Prepares the given HTTP auth data."""</span></div><div class="line"></div><div class="line">    <span class="comment"># ...</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> auth:</div><div class="line">        <span class="keyword">if</span> isinstance(auth, tuple) <span class="keyword">and</span> len(auth) == <span class="number">2</span>:</div><div class="line">            <span class="comment"># special-case basic HTTP auth</span></div><div class="line">            auth = HTTPBasicAuth(*auth)</div></pre></td></tr></table></figure>
<ul>
<li><em>requests</em>在内部将<code>(user,pass)</code>元组转换成一个鉴权类。</li>
</ul>
<h3 id="用例5：处理错误"><a href="#用例5：处理错误" class="headerlink" title="用例5：处理错误"></a>用例5：处理错误</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</div><div class="line">response = urlopen(<span class="string">'http://www.httpbin.org/geta'</span>)</div><div class="line">response.getcode()</div></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">---------------------------------------------------------------------------</div><div class="line"></div><div class="line">HTTPError                                 Traceback (most recent call last)</div><div class="line"></div><div class="line">&lt;ipython-input-45-5fba039d189a&gt; in &lt;module&gt;()</div><div class="line">      1 from urllib.request import urlopen</div><div class="line">----&gt; 2 response = urlopen('http://www.httpbin.org/geta')</div><div class="line">      3 response.getcode()</div><div class="line"></div><div class="line"></div><div class="line">/usr/lib/python3.5/urllib/request.py in urlopen(url, data, timeout, cafile, capath, cadefault, context)</div><div class="line">    161     else:</div><div class="line">    162         opener = _opener</div><div class="line">--&gt; 163     return opener.open(url, data, timeout)</div><div class="line">    164</div><div class="line">    165 def install_opener(opener):</div><div class="line"></div><div class="line"></div><div class="line">/usr/lib/python3.5/urllib/request.py in open(self, fullurl, data, timeout)</div><div class="line">    470         for processor in self.process_response.get(protocol, []):</div><div class="line">    471             meth = getattr(processor, meth_name)</div><div class="line">--&gt; 472             response = meth(req, response)</div><div class="line">    473</div><div class="line">    474         return response</div><div class="line"></div><div class="line"></div><div class="line">/usr/lib/python3.5/urllib/request.py in http_response(self, request, response)</div><div class="line">    580         if not (200 &lt;= code &lt; 300):</div><div class="line">    581             response = self.parent.error(</div><div class="line">--&gt; 582                 'http', request, response, code, msg, hdrs)</div><div class="line">    583</div><div class="line">    584         return response</div><div class="line"></div><div class="line"></div><div class="line">/usr/lib/python3.5/urllib/request.py in error(self, proto, *args)</div><div class="line">    508         if http_err:</div><div class="line">    509             args = (dict, 'default', 'http_error_default') + orig_args</div><div class="line">--&gt; 510             return self._call_chain(*args)</div><div class="line">    511</div><div class="line">    512 # XXX probably also want an abstract factory that knows when it makes</div><div class="line"></div><div class="line"></div><div class="line">/usr/lib/python3.5/urllib/request.py in _call_chain(self, chain, kind, meth_name, *args)</div><div class="line">    442         for handler in handlers:</div><div class="line">    443             func = getattr(handler, meth_name)</div><div class="line">--&gt; 444             result = func(*args)</div><div class="line">    445             if result is not None:</div><div class="line">    446                 return result</div><div class="line"></div><div class="line"></div><div class="line">/usr/lib/python3.5/urllib/request.py in http_error_default(self, req, fp, code, msg, hdrs)</div><div class="line">    588 class HTTPDefaultErrorHandler(BaseHandler):</div><div class="line">    589     def http_error_default(self, req, fp, code, msg, hdrs):</div><div class="line">--&gt; 590         raise HTTPError(req.full_url, code, msg, hdrs, fp)</div><div class="line">    591</div><div class="line">    592 class HTTPRedirectHandler(BaseHandler):</div><div class="line"></div><div class="line"></div><div class="line">HTTPError: HTTP Error 404: NOT FOUND</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> requests</div><div class="line">r = requests.get(<span class="string">'http://www.httpbin.org/geta'</span>)</div><div class="line">r.status_code</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">404</span></div></pre></td></tr></table></figure>
<h4 id="让用户选择如何处理错误"><a href="#让用户选择如何处理错误" class="headerlink" title="让用户选择如何处理错误"></a>让用户选择如何处理错误</h4><ul>
<li>有些程序员喜欢异常，而有些喜欢检查。</li>
<li>在某些情况下，检查更优雅，而有时正好相反。</li>
<li>让你的用户根据实际情况选择使用哪个比较好。</li>
<li>默认返回代码允许这样，而默认<code>exceptions</code>并不会。</li>
</ul>
<p>使用示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</div><div class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError, HTTPError</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    response = urlopen(<span class="string">'http://www.httpbin.org/geta'</span>)</div><div class="line"><span class="keyword">except</span> HTTPError <span class="keyword">as</span> e:</div><div class="line">    <span class="keyword">if</span> e.code == <span class="number">404</span>:</div><div class="line">        print(<span class="string">'Page not found'</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    print(<span class="string">'All good'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Page <span class="keyword">not</span> found</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> HTTPError</div><div class="line"><span class="keyword">import</span> requests</div><div class="line">r = requests.get(<span class="string">'http://www.httpbin.org/posta'</span>)</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    r.raise_for_status()</div><div class="line"><span class="keyword">except</span> HTTPError <span class="keyword">as</span> e:</div><div class="line">    <span class="keyword">if</span> e.response.status_code == <span class="number">404</span>:</div><div class="line">        print(<span class="string">'Page not found'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Page <span class="keyword">not</span> found</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> requests</div><div class="line">r = requests.get(<span class="string">'http://www.httpbin.org/geta'</span>)</div><div class="line"><span class="keyword">if</span> r.ok:</div><div class="line">    print(<span class="string">'All good'</span>)</div><div class="line"><span class="keyword">elif</span> r.status_code == requests.codes.not_found:</div><div class="line">    print(<span class="string">'Page not found'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Page <span class="keyword">not</span> found</div></pre></td></tr></table></figure>
<p>目前就是这样了。在准备这个演讲/文章的过程中，我学到了很多（Ele注，在翻译的时候我也学到了很多，O(∩_∩)O~），我希望你也读读它。我会很高兴在下面或者在Twitter (@noamelf)上看到你的评论（Ele注：欢迎去原文评论哈）。</p>
<h5 id="更新-2016年8月8日"><a href="#更新-2016年8月8日" class="headerlink" title="更新 (2016年8月8日)"></a>更新 (2016年8月8日)</h5><p>如果你像许多人，包括我自己一样，最终好奇为什么在Requests和Urllib之间有如此鲜明的差异。Nick Coghlan在<a href="http://noamelf.com/2016/08/05/designing-pythonic-apis/#comment-2823855721" target="_blank" rel="external">下面的注释</a>和下面的一篇博文(标题自解释): <a href="http://www.curiousefficiency.org/posts/2016/08/what-problem-does-it-solve.html" target="_blank" rel="external">它解决了什么问题？</a>(Ele注：刚好翻译了这篇的<a href="./Requests vs. urllib：它解决了什么问题？.md">中文版</a>)中分享了它关于这个问题的广阔的视角。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://lsqpyer.github.io/2017/03/17/你需要学习编写Python装饰器的五大理由/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="尋覓">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.bmp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="尋覓">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/17/你需要学习编写Python装饰器的五大理由/" itemprop="url">
                  你需要学习编写Python装饰器的五大理由
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-17T10:47:09+08:00">
                2017-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文：<a href="https://www.oreilly.com/ideas/5-reasons-you-need-to-learn-to-write-python-decorators" target="_blank" rel="external">5 reasons you need to learn to write Python decorators</a></p>
<hr>
<p>装饰器可以大大放大你所写的代码的积极影响。</p>
<p>如果你对学习如何编写Python装饰器感兴趣，并希望写出更健壮，更可靠，更可维护的Python代码，那么你会想要看看Aaron Maxwell的在线课程，<a href="https://www.oreilly.com/online-courses/python-beyond-basics.html?intcmp=il-prog-olreg-article-oltrain_5_reasons_you_need_to_learn_to_write_python_decorators_inline" target="_blank" rel="external">Python–Beyond the Basics</a>。</p>
<p>Python装饰器是很容易使用的。任何知道如何编写Python函数的人都能学习使用装饰器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">@somedecorator</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_function</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"Check it out, I'm using decorators!"</span>)</div></pre></td></tr></table></figure>
<p>但是，<em>编写</em>装饰器则是一个完全不同的技能。并且它并不简单；你必须明白：</p>
<ul>
<li>闭包</li>
<li>如果将函数作为第一类参数进行工作</li>
<li>可变参数</li>
<li>甚至是，参数解包</li>
<li>Python如何加载其源代码的一些细节。</li>
</ul>
<p>这都要花费大量的时间去理解和掌握。而你已经积压了大量的东西要学习。这值得吗？</p>
<p>对我而言，答案都是“一千次，YES！”。而且可以保证的是，对你来说，也会是这样的。编写装饰器的主要好处是什么…… 在你日常的开发中，它们怎样让你轻松有力呢？</p>
<h2 id="分析，记录和工具"><a href="#分析，记录和工具" class="headerlink" title="分析，记录和工具"></a>分析，记录和工具</h2><p>尤其是对大型应用，我们往往需要专门衡量发生了什么事，记录量化不同活动的指标。通过在它们自己的函数或方法中封装这些值得关注的事件，一个装饰器能够非常可读并且轻松地处理这种需求。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">from</span> myapp.log <span class="keyword">import</span> logger</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_order_event</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">        logger.info(<span class="string">"Ordering: %s"</span>, func.__name__)</div><div class="line">        order = func(*args, **kwargs)</div><div class="line">        logger.debug(<span class="string">"Order result: %s"</span>, order.result)</div><div class="line">        <span class="keyword">return</span> order</div><div class="line">    <span class="keyword">return</span> wrapper</div><div class="line"></div><div class="line"><span class="meta">@log_order_event</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">order_pizza</span><span class="params">(*toppings)</span>:</span></div><div class="line">    <span class="comment"># let's get some pizza!</span></div></pre></td></tr></table></figure>
<p>相同的方法可以用于记录个数或其他指标。</p>
<h2 id="验证和运行时检查"><a href="#验证和运行时检查" class="headerlink" title="验证和运行时检查"></a>验证和运行时检查</h2><p>Python的类型系统是强类型，但极具动态。由于这种好处，也意味着一些bug会试图悄悄混进来，而那些更静态类型的语言（例如JAVA）会在编译时捕获这种bug。除此之外，你可能想要在数据的出口和入口执行更加复杂的自定义检测。装饰器可以让你轻松地处理这一切，并且可以立即将其应用到许多函数。</p>
<p>想象一下：你有一组函数，每个都返回一个字典，其（在其他字段）包含了一个名为“<strong>summary</strong>”的字段。该字段的值不能超过80个字符；如果违反了，则属于错误。下面是一个装饰器，它在该错误发生时抛出一个<strong>ValueError</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate_summary</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">        data = func(*args, **kwargs)</div><div class="line">        <span class="keyword">if</span> len(data[<span class="string">"summary"</span>]) &gt; <span class="number">80</span>:</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"Summary too long"</span>)</div><div class="line">        <span class="keyword">return</span> data</div><div class="line">    <span class="keyword">return</span> wrapper</div><div class="line"></div><div class="line"><span class="meta">@validate_summary</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_customer_data</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line"></div><div class="line"><span class="meta">@validate_summary</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_orders</span><span class="params">(criteria)</span>:</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line"></div><div class="line"><span class="meta">@validate_summary</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_invoice</span><span class="params">(params)</span>:</span></div><div class="line">    <span class="comment"># ...</span></div></pre></td></tr></table></figure>
<h2 id="创建框架"><a href="#创建框架" class="headerlink" title="创建框架"></a>创建框架</h2><p>一旦你掌握了如何编写装饰器，那么你将能够从使用它们的简单语法中获益，也就是说，这让你添加语义到这个易于使用的语言中。能够扩展Python语法本身，就是另一个最好的事情。</p>
<p>事实上，许多流行的开源框架都使用它。webapp框架Flask用它来路由URL到处理该HTTP请求的函数上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment"># For a RESTful todo-list API.</span></div><div class="line"><span class="meta">@app.route("/tasks/", methods=["GET"])</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_tasks</span><span class="params">()</span>:</span></div><div class="line">    tasks = app.store.get_all_tasks()</div><div class="line">    <span class="keyword">return</span> make_response(json.dumps(tasks), <span class="number">200</span>)</div><div class="line"></div><div class="line"><span class="meta">@app.route("/tasks/", methods=["POST"])</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_task</span><span class="params">()</span>:</span></div><div class="line">    payload = request.get_json(force=<span class="keyword">True</span>)</div><div class="line">    task_id = app.store.create_task(</div><div class="line">        summary = payload[<span class="string">"summary"</span>],</div><div class="line">        description = payload[<span class="string">"description"</span>],</div><div class="line">    )</div><div class="line">    task_info = &#123;<span class="string">"id"</span>: task_id&#125;</div><div class="line">    <span class="keyword">return</span> make_response(json.dumps(task_info), <span class="number">201</span>)</div><div class="line"></div><div class="line"><span class="meta">@app.route("/tasks/&lt;int:task_id&gt;/")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">task_details</span><span class="params">(task_id)</span>:</span></div><div class="line">    task_info = app.store.task_details(task_id)</div><div class="line">    <span class="keyword">if</span> task_info <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">return</span> make_response(<span class="string">""</span>, <span class="number">404</span>)</div><div class="line">    <span class="keyword">return</span> json.dumps(task_info)</div></pre></td></tr></table></figure>
<p>这里，你有一个全局对象，名为<strong>app</strong>，以及一个名为<strong>route</strong>的方法，该方法接收某些参数。<strong>route</strong>方法返回一个装饰器，用于处理器函数。引擎之下发生的事情将非常错综复杂，但是从使用Flask的人的角度来说，所有这些复杂性都被隐藏了。</p>
<p>以这种方式使用装饰器也出现在stock Python中。例如，完全使用对象系统依赖于<strong>classmethod</strong>和<strong>property</strong>装饰器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherSimulation</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **params)</span>:</span></div><div class="line">         self.params = params</div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">for_winter</span><span class="params">(cls, **other_params)</span>:</span></div><div class="line">        params = &#123;<span class="string">'month'</span>: <span class="string">'Jan'</span>, <span class="string">'temp'</span>: <span class="string">'0'</span>&#125;</div><div class="line">        params.update(other_params)</div><div class="line">        <span class="keyword">return</span> cls(**params)</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">progress</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.completed_iterations() / self.total_iterations()</div></pre></td></tr></table></figure>
<p>这个类有三个不同的def声明。但是它们的语义完全不同：</p>
<ul>
<li>构造函数是一个普通的方法</li>
<li>for_winter是一个类方法（classmethod），提供一种工厂，而</li>
<li>progress是一个只读的动态属性</li>
</ul>
<p><strong>@classmethod</strong>和<strong>@property</strong>装饰器的简单性，使得其易于在日常使用中扩展Python对象语义。</p>
<h2 id="重用不可能重用的代码"><a href="#重用不可能重用的代码" class="headerlink" title="重用不可能重用的代码"></a>重用不可能重用的代码</h2><p>Python为你提供了一些非常强大的工具，使用表达的函数语法，函数式编程支持，以及一个全功能的对象系统，封装代码到易于重用的形式。然而，有一些代码复用模式不能被这些单独封装。</p>
<p>想想使用一个古怪的API。你通过HTTP，使用JSON向对端发起请求，在99.9%的情况下它正常工作。但是……这些请求的一些部分会使得服务器返回一个内部错误。在这种情况下，你会实现一些重试逻辑，像这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">resp = <span class="keyword">None</span></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    resp = make_api_call()</div><div class="line">    <span class="keyword">if</span> resp.status_code == <span class="number">500</span> <span class="keyword">and</span> tries &lt; MAX_TRIES:</div><div class="line">        tries += <span class="number">1</span></div><div class="line">        <span class="keyword">continue</span></div><div class="line">    <span class="keyword">break</span></div><div class="line">process_response(resp)</div></pre></td></tr></table></figure>
<p>现在，想象一下，你有几十个类似于<strong>make_api_call()</strong>的函数，它们被整个代码库调用。你要到处实现那个while循环吗？你要在每次添加一个新的API调用函数时都来一遍？这种模式使得它难以拥有样板代码。除非你使用装饰器。然后，它很简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment"># The decorated function returns a Response object,</span></div><div class="line"><span class="comment"># which has a status_code attribute. 200 means</span></div><div class="line"><span class="comment"># success; 500 indicates a server-side error.</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">retry</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">retried_func</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">        MAX_TRIES = <span class="number">3</span></div><div class="line">        tries = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            resp = func(*args, **kwargs)</div><div class="line">            <span class="keyword">if</span> resp.status_code == <span class="number">500</span> <span class="keyword">and</span> tries &lt; MAX_TRIES:</div><div class="line">                tries += <span class="number">1</span></div><div class="line">                <span class="keyword">continue</span></div><div class="line">            <span class="keyword">break</span></div><div class="line">        <span class="keyword">return</span> resp</div><div class="line">    <span class="keyword">return</span> retried_func</div><div class="line"></div><div class="line"><span class="comment"># This gives you an easy-to-use @retry decorator:</span></div><div class="line"></div><div class="line"><span class="meta">@retry</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_api_call</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment"># ....</span></div></pre></td></tr></table></figure>
<h2 id="发展你的事业"><a href="#发展你的事业" class="headerlink" title="发展你的事业"></a>发展你的事业</h2><p>编写装饰器在开始并不容易。它不是一飞冲天，但需要足够的努力来学习，以及充分了解细微差别，因此，许多开发者永远都不会费心思去掌握它。这就使你加分不少。当你成为了你的团队中那个写得一手好装饰器的人，并且编写了可以解决实际问题的装饰器，那么其他开发者将会使用它们。因为一旦编写它们这一项工作完成了，那么装饰器是很容易使用的。这可以<strong>大规模</strong>放大你所写的代码的积极影响。并且，它还有可能让你成为一个英雄哦。</p>
<p>随着我远行，培训了数百名正在工作的软件工程师更有效地使用Python，团队不断地在反馈，编写装饰器是他们在我的高级Python编程工场中学习到的最有价值以及最重要的工具。这就是为什么它是即将到来的2016年5月25日和26日的<a href="http://www.oreilly.com/online-courses/python-beyond-basics.html?intcmp=il-prog-olreg-article-oltrain_5_reasons_you_need_to_learn_to_write_python_decorators_inline" target="_blank" rel="external">Python: Beyond the Basics</a>在线课程的关键部分。</p>
<p>无论你如何学会写装饰器，你都可以兴奋于能够用它们所做到的事，以及它将如何，不是开玩笑的，永远改变你编写Python代码的方式！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://lsqpyer.github.io/2017/03/16/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="尋覓">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.bmp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="尋覓">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/16/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-16T11:00:57+08:00">
                2017-03-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  

          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/header.bmp"
               alt="尋覓" />
          <p class="site-author-name" itemprop="name">尋覓</p>
           
              <p class="site-description motion-element" itemprop="description">尋覓</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">尋覓</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
